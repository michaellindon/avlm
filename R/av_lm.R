#' Convert a Linear Model (lm) Object to Anytime-Valid lm (avlm)
#'
#' Converts an \code{lm} object into an anytime-valid version by storing a precision parameter
#' \code{g} as an attribute and updating the object's class. The resulting object supports anytime-valid inference.
#'
#' @param model An \code{lm} object from a linear model fit.
#' @param g An integer precision parameter for anytime-valid inference. Default is 1.
#' @param ... Additional arguments passed to or from other methods.
#'
#' @return An enhanced \code{lm} object of class \code{avlm} with anytime-valid inference capabilities.
#' @export
av.lm <- function(model, g = 1, ...) {
  attr(model, "g") <- g
  class(model) <- c("avlm", class(model))
  return(model)
}


#' Summary Method for Anytime-Valid lm (avlm) Objects
#'
#' Computes a summary for an \code{avlm} object, a linear model enhanced with anytime-valid inference.
#' In addition to the standard \code{lm} summary statistics, the p-values for the coefficient tests are
#' recalculated using an anytime-valid method.
#'
#' @param object An \code{avlm} object generated by \code{av.lm}.
#' @param ... Additional arguments passed to or from other methods.
#'
#' @return A summary object of class \code{summary.avlm} that includes updated p-values for the coefficients.
#' @export
summary.avlm <- function(object, ...) {
  # First get the regular lm summary
  summ <- NextMethod()
  
  # Change the class to include summary.avlm first 
  class(summ) <- c("summary.avlm", "summary.lm")
  
  # Add any additional elements specific to avlm
  g <- attr(object, "g")
  attr(summ, "g") <- g
  number_of_coefficients = dim(summ$cov.unscaled)[1]
  n = length(summ$residuals)
  t = summ$coefficients[, 't value']
  t2 = t ^ 2
  
  p = number_of_coefficients - 1
  d = 1
  nu = n - p - d

  log_G_t_values = log_G_t(t2, nu, n, g)
  summ$coefficients[,4] = p_G_t(log_G_t_values)
  
  
  return(summ)
}


#' Print Method for summary.avlm Objects
#'
#' Custom print method for \code{summary.avlm} objects that mimics the standard \code{summary.lm} output,
#' but replaces p-value column headers and includes anytime-valid annotations.
#'
#' @param x An object of class \code{summary.avlm} containing the summary of an anytime-valid lm object.
#' @param digits The number of significant digits to use when printing. Defaults based on system options.
#' @param signif.stars Logical indicating whether significance stars should be printed.
#' @param ... Additional arguments passed to or from other methods.
#'
#' @return Invisibly returns the summary object.
#' @export
print.summary.avlm <- function(x, digits = max(3L, getOption("digits") - 3L), 
                               signif.stars = getOption("show.signif.stars"), ...) {
  # Don't call NextMethod() - we'll implement our own printing
  # that closely follows the standard summary.lm printing
  
  cat("\nCall:\n", paste(deparse(x$call), sep = "\n", collapse = "\n"), "\n\n", sep = "")
  
  # Print residuals
  resid <- x$residuals
  cat("Residuals:\n")
  if (length(resid) > 5) {
    rq <- quantile(resid)
    names(rq) <- c("Min", "1Q", "Median", "3Q", "Max")
    print(rq, digits = digits)
  } else {
    print(resid, digits = digits)
  }
  
  # Print coefficients
  cat("\nCoefficients:\n")
  regression_table <- capture.output({
    printCoefmat(x$coefficients, digits = digits, signif.stars = signif.stars, ...)
  })
  # Replace the p-value column header text
  output <- sub("Pr\\(>\\|t\\|\\)", "p value", regression_table)
  
  # Print the modified output
  cat(paste(output, collapse = "\n"))
  
  # Print residual standard error
  cat("\nResidual standard error:", format(x$sigma, digits = digits), 
      "on", x$df[2], "degrees of freedom")
  
  # Print NA handling message if needed
  if (nzchar(mess <- naprint(x$na.action))) 
    cat("\n (", mess, ")\n", sep = "")
  else cat("\n")
  
  # Print R-squared and F-statistic with custom p-value
  if (!is.null(x$fstatistic)) {
    cat("Multiple R-squared:  ", formatC(x$r.squared, digits = digits),
        ",\tAdjusted R-squared:  ", formatC(x$adj.r.squared, digits = digits), 
        "\n", sep = "")

    # Calculate custom p-value for F-statistic
    g <- attr(x, "g")
    f <- x$fstatistic[1]
    n = length(x$residuals)
    d = x$fstatistic[2]
    nu <- x$fstatistic[3] #n - p - d
    f_spvalue = min(1.0, exp(-1*log_G_f(f, d, nu, n, g)))
    
    # Print F-statistic with custom p-value
    cat("F-statistic:", formatC(f, digits = digits), 
        "on", d, "and", nu, "DF,  p-value:", 
        format.pval(f_spvalue, digits = digits), "\n")
  }
  
  cat("Anytime-Valid: TRUE\n")

  invisible(x)
}


#' Confidence Intervals for Anytime-Valid lm (avlm) Objects
#'
#' Computes confidence intervals for the coefficients of an \code{avlm} object by adjusting
#' the standard errors using the precision parameter \code{g} and an anytime-valid approach.
#'
#' @param object An \code{avlm} object.
#' @param parm A specification of which parameters are to be given confidence intervals; can be a vector of numbers or names.
#' @param level The confidence level required for the intervals. Defaults to 0.95.
#' @param ... Additional arguments passed to or from other methods.
#'
#' @return A matrix with the lower and upper confidence limits for the specified parameters.
#' @export
confint.avlm <- function(object, parm, level = 0.95, ...) {
  # Get the standard confidence intervals from lm
  # We'll use the standard method as a starting point
  orig_confint <- NextMethod()
  
  # Extract needed components for custom CI calculation
  coefs <- coef(object)
  se <- summary(object)$coefficients[, 2]
  g <- attr(object, "g")  # The avlm-specific parameter
  n <- length(object$residuals)
  
  # Parameter selection (same as in the standard method)
  if (missing(parm)) {
    parm <- names(coefs)
  } else if (is.numeric(parm)) {
    parm <- names(coefs)[parm]
  }
  
  # Calculate custom confidence intervals that incorporate g
  alpha <- 1 - level
  critval <- sqrt(((g + n) / n) * log((g + n) / (g * alpha^2)))
  
  # Example custom calculation (replace with your own method)
  # Here we're adjusting the standard errors using g
  adjusted_se <- se / sqrt(g)
  
  # Create the CI matrix
  custom_ci <- matrix(NA, length(parm), 2)
  rownames(custom_ci) <- parm
  colnames(custom_ci) <- c(paste(format(100 * alpha/2, digits = 3), "%"), 
                           paste(format(100 * (1 - alpha/2), digits = 3), "%"))
  
  # Fill in the confidence intervals
  for (i in seq_along(parm)) {
    param_name <- parm[i]
    if (param_name %in% names(coefs)) {
      idx <- which(names(coefs) == param_name)
      custom_ci[i, 1] <- coefs[idx] - critval * adjusted_se[idx]
      custom_ci[i, 2] <- coefs[idx] + critval * adjusted_se[idx]
    }
  }
  
  return(custom_ci)
}
